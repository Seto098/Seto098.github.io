{"pages":[{"title":"标签","text":"","link":"/tags/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"【TA从入门到放弃】【一】","text":"我也想做TA [TOC] Shader Graph基本使用 在unity导航栏Window-&gt;Packagr Manager搜索Shader Graph安装 创建ShaderGraph文件 通过Project右键Create-&gt;Shader创建ShaderGraph文件Unlit Graph不受光照PBR GraphPBRSub Graph可创建复杂节点 参数PBR Graph（physically base rendering)用于制作基于物理的Shader Vertex Position 顶点在模型空间中坐标 Vertex Normal 顶点法线 Vertex Tangent 顶点法线切线 Albedo 反射率 Normal 法线 Emission 自发光 Metallic 金属度 Smoothness 表面光滑 Occlusion 环境光阻挡 Alpha 透明度 AlphaClipThreshold alpha钳制 Workflow 材质球Metallic或Specular模式 Surface 材质不透明Opaque透明Transparent Blend 给透明材质球指定混合模式 Fragment Normal Space Two Sided 模型是否双面渲染 创建节点ShaderGraph错误 package manager搜索High Definition Render Pipeline安装 创建HDRP管道 1project右键 --&gt; Create --&gt; Rendering --&gt; URP --&gt; High Definition Render Pipeline Asset 将渲染管道放到Scriptable Render Pipeline Settings中 Unity Shader Graph获取关照方向 12345678#if SHADERGRAPH_PREVIEW Direction = half3(0.5,0.5,0); Color = 1;#else Light light = GetMainLight(); Direction = light.direction; Color = light.color;#endif","link":"/2021/09/16/TA%E5%85%A5%E9%97%A8-2021-09-16-TA%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"UnityShader入门精要【基础篇】","text":"一直都在学，但是就是学不会 渲染管线一个渲染流程分三阶段：应用阶段Application Stage，几何阶段Geometry Stage，光栅化阶段Rasterizer Stage 应用阶段 通常由CPU负责实现，由开发者准备场景：摄像机模型光源等数据，设置渲染状态。 这一阶段最重要的输出是渲染所需的几何信息，即渲染图元（rendering primitives）。 几何阶段 通常在GPU上进行，处理所有要绘制的几何相关的。 负责每个渲染图元，进行逐顶点逐多边形的操作 把顶点坐标转换到屏幕空间 光栅化阶段 在GPU上运行。 对几何阶段得到的顶点数据（纹理坐标、顶点颜色等）进行插值，进行像素处理。 CPU和GPU之间的通信渲染管线的起点是CPU，即应用阶段。 把数据加载到显存中 所有数据都要从硬盘加载到系统内存，然后网格和纹理等数据加载到显存中。 设置渲染状态 定于场景中的网格是怎样被渲染的。 调用Draw Call 由CPU发出，指向一个要被渲染的图元（primitives）列表。当给定了一个Draw Call时，GPU会根据渲染状态（材质、纹理、着色器等）和所有输入的顶点数据来进行计算。计算过程就是GPU渲染管线。 GPU渲染管线 graph LR A[顶点数据] K[屏幕图像] A-->B subgraph -几何阶段 subgraph -可完全编程控制 B[顶点着色器] subgraph -可选 C[曲面细分着色器] D[几何着色器] end end subgraph -可配置但不可编程 E[裁剪] end subgraph -固定实现没控制权 F[屏幕映射] end B-->C-->D-->E-->F end subgraph 光栅化阶段- subgraph 可完全编程控制- subgraph 可选- I[片元着色器] end end subgraph 可配置但不可编程- J[逐片元操作] end subgraph 固定实现没控制权- G[三角形设置] H[三角形遍历] end G-->H-->I-->J end J-->K","link":"/2021/10/02/TA%E5%85%A5%E9%97%A8-2021-10-02-UnityShader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E3%80%90%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%91/"},{"title":"UnityShader学习【一】","text":"一个Shader的学习记录 [TOC] UnityShader属性类型 123456789101112131415//自带颜色参数_Color(&quot;Color&quot;,Color)=(0,1,1,1)//四维向量xyzw,rgba_Vector(&quot;Vector&quot;,Vector)=(1,2,3,4)//整数_Int(&quot;Int&quot;,Int)=1//浮点数_Float(&quot;Float&quot;,float)=23.1//范围_Range(&quot;Range&quot;,Range(1,0))=0.5//2D 3D纹理，不指定图片默认为white_2D(&quot;2DTexture&quot;,2D)=&quot;white&quot;{}_3D(&quot;3DTexture&quot;,3D)=&quot;white&quot;{}//立方体纹理,不指定图片默认为white_Cube(&quot;Cube&quot;,Cube)=&quot;white&quot;{} uniyuCG.cginc中常用函数 视角方向 123456//模型空间中的顶点坐标-&gt;世界空间从这个点到摄像机的观察方向float3 WorldSpaceViewDir(float4 v)//世界空间中的顶点坐标-&gt;世界空间从这个点到摄像机的观察方向float3 UnityWorldSpaceViewDir(float4 v)//模型空间中的顶点坐标-&gt;模型空间从这个点到摄像机的观察方向float3 ObjSpaceViewDir(float4 v) 光源方向 123456//模型空间中的顶点坐标-&gt;世界空间中从这个点到光源的方向float3 WorldSpaceLightDir(float4 v)//世界空间中的顶点坐标-&gt;世界空间中从这个点到光源的方向float3 UnityWorldSpaceLightDir(float4 v)//模型空间中的顶点坐标-&gt;模型空间中从这个点到光源的方向float3 ObjSpaceLightDir(float4 v) _WorldSpqceLightPos0 世界坐标中光源的位置或方向向量如_WorldSpqceLightPos0.ww为0为平行光，w为1则为点光源或聚光灯 方向转换 123456//法线方向从模型空间-&gt;世界空间float3 UnityObjectToWorldNormal(float3 norm)//把方向 模型空间-&gt;世界空间float3 UnityObjectToWorldDir(float3 dir)//把方向 世界空间-&gt;模型空间float3 UnityWorldToObjectDir(float3 dir) 从应用程序传递到顶点函数的语义a2v（application to vertex） 12345POSITION------顶点坐标NORMAL--------法线TANGENT-------切线TEXCOORD0~n---纹理坐标COLOR---------顶点颜色 从顶点函数传递给片元函数的语义 1234SV_POSITION---剪裁空间中的顶点坐标COLOR0--------可以传递一组4个值COLOR1--------可以传递一组4个值TEXCOORD0~7---传递纹理坐标 片元函数传递给系统 1SV_TARGET-----颜色值，显示到屏幕上的颜色 ShaderLab属性类型和CG变量类型的匹配关系 ShaderLab属性类型 CG变量类型 Color, Vector float4 half4 fixed4 Range, Float float, half, fixed 2D sampler2D Cube samplerCube 3D sampler3D 从应用阶段传递模型数据给顶点着色器时unity支持的常用语义 语义 描述 POSITION 模型空间中的顶点位置，通常为float4类型 NORMAL 顶点法线，通常是float3类型 TANGENT 顶点切线，通常是float4类型 TEXCOORD0TEXCOORD1 该顶点的纹理坐标，通常是float2或float4类型 COLOR 顶点颜色，通常是fixed4或float4类型 常用数学函数 函数 作用 dot( A , B ) 返回 A 和 B 的点积(dot product)。参数 A 和 B 可以是标量，也可以是向量 pow( A , B ) 返回 A 的 B 次方 函数 作用 saturate(x) 如果 x 小于 0，返回 0；如果 x 大于 1，返回1；否则，返回 x mul(M, N) 计算两个矩阵相乘，如果 M 为 AxB 阶矩阵，N 为 BxC阶矩阵，则返回 AxC 阶矩阵。 几何函数（Geometric Functions） 函数 作用 normalize( v) 对向量进行归一化 第一个顶点/片元着色器 12345678910111213141516171819202122232425262728//定义这个Unity Shader的名字Shader &quot;Custom/Learn_SimpleShader01&quot;{ SubShader{ Pass{ CGPROGRAM //#pragma vertex name //#pragma fragment name //声明了一个顶点函数vert和片元函数frag #pragma vertex vert #pragma fragment frag //POSITION把顶点坐标返回给v //SV_POSITION把值v作为裁剪空间中的顶点坐标 float4 vert(float4 v : POSITION):SV_POSITION{ return UnityObjectToClipPos(v); } //SV_TARGET返回黄色 float4 frag():SV_TARGET{ return float4(1,1,0,1); } ENDCG } } Fallback &quot;VertexLit&quot;} 一个带结构体的着色器从顶点着色器输出一些数据（法线、纹理坐标等）传递给片元着色器，涉及到顶点着色器和片元着色器之间的通信。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Shader &quot;Custom/Learn_SimpleShader02&quot;{ SubShader { pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag //application to vertex //应用程序传递到顶点函数 //使用一个结构体a2v来定义顶点着色器的输入 struct a2v{ //用模型空间的顶点坐标填充vertex变量 float4 vertex : POSITION; //用模型空间的法线坐标填充normal变量 float3 normal : NORMAL; //用模型的第一套纹理坐标填充texcoord变量 float4 texcoord : TEXCOORD0; }; //vertex to fragment //顶点函数传递到片元函数 //使用一个结构体v2f来定义顶点着色器的输出 struct v2f{ //pos里包含了顶点在裁剪空间中的位置信息 float4 pos : SV_POSITION; //COLOR0于一可以存储颜色信息 float3 color : COLOR0; }; v2f vert(a2v v){ //声明输出结构 v2f o; o.pos=UnityObjectToClipPos(v.vertex); //v.normal包含了顶点的法线方向，范围在[-1.0,1.0] //映射到[0.0,1.0]存储在o.color中传递给片元着色器 o.color=v.normal * 0.5 + float3(0.5,0.5,0.5); return o; } float4 frag(v2f i):SV_TARGET{ //将i.color值显示到屏幕 return float4(i.color,1); } ENDCG } } Fallback &quot;VertexLit&quot;} 一个带可控属性的简单着色器 1234567891011121314151617181920212223242526272829303132333435363738394041Shader &quot;Learn_SimpleShader03&quot;{ Properties{ //声明一个Color类型的属性 _Color(&quot;Diffuse Color&quot;,Color)=(1,1,1,1.0) } SubShader{ pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag //定义一个与属性名称和类型匹配的变量 float4 _Color; struct a2v{ float4 vertex : POSITION; float4 normal : NORMAL; }; struct v2f{ float4 pos : SV_POSITION; float3 color : COLOR0; }; v2f vert(a2v v){ v2f o; o.pos=UnityObjectToClipPos(v.vertex); o.color=float3(1,1,1); return o; } float4 frag(v2f i) : SV_TARGET{ float3 c = i.color; c *= _Color.rgb; return float4(c,1.0); } ENDCG } } Fallback &quot;VertexLit&quot;} 漫反射（diffuse) Clight ———入射光线的颜色和强度Mdiffuse ——材质的漫反射系数n ————–表面法线I —————光源方向 逐顶点漫反射光照 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859Shader &quot;Custom/Learn02_DiffuseVertex&quot;{ properties{ _DiffuseColor(&quot;Diffuse Color&quot;,Color)=(1,1,1) } SubShader{ Pass{ //定义了LightMode才能得到一些Unity的内置光照变量 Tags{&quot;LightMode&quot;=&quot;ForwardBase&quot;} CGPROGRAM #pragma vertex vert #pragma fragment frag //引用Unity内置文件 #include &quot;Lighting.cginc&quot; fixed3 _DiffuseColor; struct a2v{ //获取模型空间下的顶点坐标 float4 vertex : POSITION; //获取模型空间下的顶点法线 float3 normal : NORMAL; }; struct v2f{ float4 pos : SV_POSITION; fixed3 diffuseColor : COlOR0; }; v2f vert(a2v v){ v2f o; //把顶点位置从模型空间转换到裁剪空间中 o.pos = UnityObjectToClipPos(v.vertex); //获取平行光的颜色 fixed3 ambient = _LightColor0.rgb; //取得世界空间下的光方向 fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz); //将在模型空间取得的模型法线转换到世界空间 fixed3 normalDir = normalize(mul((float3x3)unity_ObjectToWorld,v.normal)); // 根据公式输出结果 o.diffuseColor = (ambient * _DiffuseColor.xyz) * saturate(dot(normalDir,worldLight)); return o; } fixed4 frag(v2f i) : SV_TARGET{ return float4(i.diffuseColor,1); } ENDCG } } Fallback &quot;Diffuse&quot;} 对于一些细分程度低的模型，逐顶点光照会出现视觉问题，如悲观面和向光面交界处有锯齿。 逐像素漫反射光照 123456789101112131415161718192021222324252627282930313233343536373839404142434445Shader &quot;Custom/Learn02_DiffusePixel&quot;{ properties{ _DiffuseColor(&quot;Diffuse Color&quot;,Color) = (1,1,1,1) } SubShader{ Pass{ Tags{&quot;LightMode&quot;=&quot;ForwardBase&quot;} CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed3 _DiffuseColor; struct a2v{ float4 vertex : POSITION; fixed3 normal : NORMAL; }; struct v2f{ float4 pos : SV_POSITION; fixed3 normalDir : COLOR0; }; v2f vert(a2v v){ v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.normalDir = normalize(mul((float3x3)unity_ObjectToWorld,v.normal)); return o; } fixed4 frag(v2f i) : SV_TARGET{ fixed3 ambient = _LightColor0.rgb; fixed3 worldLightPos = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuseColor = (ambient * _DiffuseColor) * saturate(dot(worldLightPos,i.normalDir)); return fixed4(diffuseColor,1); } ENDCG } } Fallback &quot;Diffuse&quot;} 兰伯特模型（Half Lambert） 以上的漫反射光照模型也被称为兰伯特光照模型，因为它符合兰伯特定律——在平面某点漫反射光的光强与该反射点的法向量和入射光角度的余弦值成正比。 广义的半兰伯特光照模型公式如下： 和原兰伯特模型相比，半兰伯特光照模型没有使用max来操作防止 n , I 的点积为负值。而是对其结果进行了一个α缩放和β大小的偏移。通过这样，可以将dot(n , I)的结果范围从[-1,1]映射到[0,1]。 Clight ———入射光线的颜色和强度Mdiffuse ——材质的漫反射系数n ————–表面法线I —————光源方向 1fixed3 diffuseColor = (ambient * _DiffuseColor) * (0.5 * dot(worldLightPos,i.normalDir) + 0.5); 高光反射（Specular） Clight ———入射光线的颜色和强度Mspecular —-材质的高光反射系数v ————–视角方向r ————–反射方向 反射方向 r 可以由表面法线 n 和光源方向 I 计算所得： CG也提供了计算反射方向的函数 reflect(i , n) i —–光源入射方向n —-法线方向 当给定入射方向和法线方向时，reflect函数可以返回反射方向 逐顶点反射12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Shader &quot;Learn02_SpecularVertex&quot;{ properties{ _DiffuseColor(&quot;DiffuseColor&quot;,Color) = (1,1,1,1) _Specular(&quot;Specular&quot;,Color) = (1,1,1,1) _Gloss(&quot;Gloss&quot;,Range(8,256)) = 50 } SubShader{ Pass{ Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;} CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed3 _DiffuseColor; fixed3 _Specular; float _Gloss; struct a2v{ float4 vertex : POSITION; fixed3 normal : NORMAL; }; struct v2f{ float4 pos : SV_POSITION; float3 color : COLOR0; }; v2f vert(a2v v){ v2f o; o.pos =UnityObjectToClipPos(v.vertex); //平行光颜色 fixed3 ambient = _LightColor0.rgb; //光源方向 fixed3 worldLightPos = normalize(_WorldSpaceLightPos0.xyz); //将顶点法线转换到世界空间 fixed3 normalDir = normalize(mul((float3x3)unity_ObjectToWorld,v.normal)); //漫反射 fixed3 diffuseColor = (ambient * _DiffuseColor) * (0.5 + 0.5 * dot(worldLightPos,normalDir)); //计算反射方向 //reflect 函数的入射方向是由光源指向交点，所以参数要取负 fixed3 reflectDir = normalize(reflect(-worldLightPos,normalDir)); //计算视角方向 fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld,v.vertex).xyz); //高光 fixed3 specularColor = (ambient *_Specular) * pow(saturate(dot(viewDir,reflectDir)),_Gloss); o.color = specularColor + diffuseColor; return o; } fixed4 frag(v2f i) : SV_TARGET{ return fixed4(i.color,1); } ENDCG } } Fallback &quot;Diffuse&quot;} 逐像素反射12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Shader &quot;Custom/Learn02_SpecularPixel&quot;{ properties{ _DiffuseColor(&quot;DiffuseColor&quot;,Color) = (1,1,1,1) _Specular(&quot;Specular&quot;,Color) = (1,1,1,1) _Gloss(&quot;Gloss&quot;,Range(8,256)) = 50 } SubShader{ Pass{ Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;} CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed3 _DiffuseColor; fixed3 _Specular; float _Gloss; struct a2v{ float4 vertex : POSITION; fixed3 normal : NORMAL; }; struct v2f{ float4 pos : SV_POSITION; fixed3 worldNormal : COLOR0; fixed3 worldPos : COLOR1; }; v2f vert(a2v v){ v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = normalize(mul((float3x3)unity_ObjectToWorld,v.normal)); o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz; return o; } fixed4 frag(v2f i) : SV_TARGET{ fixed3 ambient = _LightColor0.rgb; fixed3 worldLightPos = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuseColor = (ambient * _DiffuseColor) * (0.5 + 0.5 * dot(worldLightPos,i.worldNormal)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldNormal.xyz); fixed3 reflectDir = normalize(reflect(-worldLightPos,i.worldNormal)); fixed3 specularColor = (ambient * _Specular) * pow(saturate(dot(viewDir,reflectDir)),_Gloss); fixed3 color = diffuseColor + specularColor; return fixed4(color,1); } ENDCG } }} Blinn-Phong1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Shader &quot;Custom/Learn02_SpecularBlinn&quot;{ Properties{ _DiffuseColor(&quot;DiffuseColor&quot;,Color) = (1,1,1,1) _Specular(&quot;Speculaar&quot;,Color) = (1,1,1,1) _Gloss(&quot;Gloss&quot;,Range(8,256)) = 8 } SubShader{ Pass{ Tags{&quot;LightMode&quot; = &quot;ForwardBase&quot;} CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed3 _DiffuseColor; fixed3 _Specular; float _Gloss; struct a2v{ float4 vertex : POSITION; fixed3 normal : NORMAL; }; struct v2f{ float4 pos : SV_POSITION; fixed3 worldNormal : COLOR0; fixed3 worldVertex : COLOR1; }; v2f vert(a2v v){ v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = mul((float3x3)unity_ObjectToWorld,v.normal); o.worldVertex = mul(unity_ObjectToWorld,v.vertex); return o; } fixed4 frag(v2f i) : SV_TARGET{ fixed3 ambient = _LightColor0.rgb; fixed3 normalDir = normalize(i.worldNormal); fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuseColor = (ambient * _DiffuseColor) * (0.5 + 0.5 * dot(normalDir,lightDir)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldVertex.xyz); fixed3 halfDir = normalize(viewDir + lightDir); fixed3 specularColor = (ambient * _Specular) * pow(max(0,dot(normalDir,halfDir)),_Gloss); fixed3 color = specularColor; return fixed4(color,1); } ENDCG } }}","link":"/2021/10/02/TA%E5%85%A5%E9%97%A8-2021-10-02-UnityShader%E5%AD%A6%E4%B9%A0%E3%80%90%E4%B8%80%E3%80%91/"},{"title":"PHP期末作业","text":"是个PHP的期末作业 登陆注册 学生教师端 增删查改 引入header和Footer12include('Menu/header.php');include('Menu/footer.php'); 注册登录系统数据库创建注册表1234567CREATE TABLE `register` ( `userId` int(20) NOT NULL AUTO_INCREMENT COMMENT '用户id', `userName` varchar(60) NOT NULL COMMENT '用户名', `passWord` varchar(60) NOT NULL COMMENT '用户密码', `passWordConfirm` varchar(60) NOT NULL COMMENT '确认密码', PRIMARY KEY (`userId`)) ENGINE=MyISAM AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 数据库连接连接库1$con=new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;user&quot;,&quot;3306&quot;); 测试连接123if($getCon-&gt;connect_error) { die(&quot;连接失败:&quot;.$getCon-&gt;connect_error);} 解决乱码1mysqli_query($getCon,&quot;set names utf8&quot;); 登录获取表单数据12$userName=$_POST['userName'];$passWord=$_POST['passWord']; 从数据库获取数据数据查询语句12$selData=&quot;select userName from $tableNam where userName='$userName' and passWord='$passWord';&quot;; 判断账号密码12345678910111213$que=mysqli_query($getCon,$selData);$res=mysqli_fetch_row($que);if($res){ echo &quot;&lt;script&gt; alert('$userName 登入成功'); self.location='../index.php'; &lt;/script&gt;&quot;;}else{ echo &quot;&lt;script&gt; alert('账号或密码错误,重新输入'); &lt;/script&gt;&quot;; } 注册获取表单数据123$userName=$_POST['userName'];$passWord=$_POST['passWord'];$passWordConfirm=$_POST['passWordConfirm']; 上传数据到数据库数据添加语句12$insertData=&quot;insert into register(userName,passWord,passWordConfirm) value('$userName','$passWord','$passWordConfirm');&quot;; 判断用户名占用12345678$sel=&quot;select userName from $tableNam where userName = '$userName';&quot;;$que=mysqli_query($getCon,$sel);$pal=mysqli_fetch_row($que);if($pal){ echo &quot;&lt;script&gt; alert('注册失败,用户$userName 已被占用'); &lt;/script&gt;&quot;;} 执行上传数据库123456789if($getCon-&gt;query($insertData)){ echo &quot;&lt;script&gt; alert('注册成功'); self.location='./login.php'; &lt;/script&gt;&quot;;}else{ echo &quot;&lt;script&gt;alert('注册失败')&lt;/script&gt;&quot;;} 选课系统数据库导入数据库1source S:\\Wamp\\www\\xk.sql 连接数据库1$con=new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;management&quot;,&quot;3306&quot;); 测试连接123if($getCon-&gt;connect_error) { die(&quot;连接失败:&quot;.$getCon-&gt;connect_error);} 解决乱码1mysqli_query($getCon,&quot;set names utf8&quot;); 学生端课程预览学生信息学生选课所有课程输出123$selAllCou=&quot;SELECT CouName,Kind,Teacher,SchoolTime,CouNo FROM course; &quot;; 查看已选课程12345$selCoued=&quot;SELECT c.CouName,c.Kind,c.Teacher,c.SchoolTime,c.CouNo FROM student s,course c,stucou sc WHERE s.StuNo=sc.StuNo AND c.CouNo=sc.CouNo AND s.StuNo='$StuNo' GROUP BY c.CouName; &quot;; 查看未选课程12345$selCouNo=&quot;SELECT c.CouName,c.Kind,c.Teacher,c.SchoolTime,c.CouNo FROM student s,course c,stucou sc WHERE s.StuNo=sc.StuNo AND c.CouNo!=sc.CouNo AND s.StuNo='$StuNo' GROUP BY c.CouName; &quot;; 执行12$resSelEd=mysqli_query($getCon,$selCoued);$resSelNo=mysqli_query($getCon,$selCouNo); 循环执行输出已选部分1234567891011while($row=mysqli_fetch_array($resSelEd)){ echo&quot; &lt;tr class=\\&quot;showCouCen\\&quot;&gt; &lt;td&gt;{$row['CouName']}&lt;/td&gt; &lt;td&gt;{$row['Kind']}&lt;/td&gt; &lt;td&gt;{$row['Teacher']}&lt;/td&gt; &lt;td&gt;{$row['SchoolTime']}&lt;/td&gt; &lt;td&gt;&lt;input type='checkbox' value='{$row['CouNo']}' name='chebox[]' checked='checked' onclick='che(this)'&gt;&lt;/td&gt; &lt;/tr&gt; &quot;;} 输出未选部分1234567891011while($row=mysqli_fetch_array($resSelNo)){ echo&quot; &lt;tr class=\\&quot;showCouCen\\&quot;&gt; &lt;td&gt;{$row['CouName']}&lt;/td&gt; &lt;td&gt;{$row['Kind']}&lt;/td&gt; &lt;td&gt;{$row['Teacher']}&lt;/td&gt; &lt;td&gt;{$row['SchoolTime']}&lt;/td&gt; &lt;td&gt;&lt;input type='checkbox' value='{$row['CouNo']}' name='chebox[]' onclick='che(this)'&gt;&lt;/td&gt; &lt;/tr&gt; &quot;;} 选课条件1234567891011echo &quot;&lt;script&gt; var st=0,max=5 - $StuSum; function che(obj){ obj.checked?st++:st--; if(st&gt;max){ obj.checked=false; alert('只能选五门'); st--; } }&lt;/script&gt;&quot;; 修改选课删除学生选课删除选课123$delCou=&quot;DELETE FROM stucou WHERE StuNo='$StuNo'; &quot;; 执行1mysqli_query($getCon,$delCou); 更新选课获取已选课数1$sum=count($chebox); 更新数据库123456for($i=0;$i&lt;$sum;$i+=1){ $ChoCou=&quot;INSERT INTO stucou(StuNo,CouNo,WillOrder,state) VALUE('$StuNo','$chebox[$i]',$i,'报名'); &quot;; mysqli_query($getCon,$ChoCou);} 教师端浏览课程查询语句1$selCourse=&quot;select*from course&quot;; 执行语句1$resSel=mysqli_query($getCon,$selCourse); 循环执行12345678910111213141516while($row=mysqli_fetch_array($resSel)){ echo&quot; &lt;tr class=\\&quot;showCouCen\\&quot;&gt; &lt;td&gt;{$row['CouNo']}&lt;/td&gt; &lt;td&gt;{$row['CouName']}&lt;/td&gt; &lt;td&gt;{$row['Kind']}&lt;/td&gt; &lt;td&gt;{$row['Credit']}&lt;/td&gt; &lt;td&gt;{$row['Teacher']}&lt;/td&gt; &lt;td&gt;{$row['DepartNo']}&lt;/td&gt; &lt;td&gt;{$row['SchoolTime']}&lt;/td&gt; &lt;td&gt;{$row['LimitNum']}&lt;/td&gt; &lt;td&gt;{$row['WillNum']}&lt;/td&gt; &lt;td&gt;{$row['ChooseNum']}&lt;/td&gt; &lt;/tr&gt; &quot;; } 增加课程获取插入数据12345678910$CouNo=$_POST['CouNo'];$CouName==$_POST['CouName'];$Kind=$_POST['Kind'];$Credit=$_POST['Credit'];$Teacher=$_POST['Teacher'];$DepartNo=$_POST['DepartNo'];$SchoolTime=$_POST['SchoolTime'];$LimitNum=$_POST['LimitNum'];$WillNum=$_POST['WillNum'];$ChooseNum=$_POST['ChooseNum']; 插入语句12345$insCourse=&quot;insert into course(CouNo,CouName,Kind,Credit,Teacher,DepartNo,SchoolTime,LimitNum,WillNum,ChooseNum)value($CouNo,'$CouName','$Kind',$Credit,'$Teacher',$DepartNo,'$SchoolTime',$LimitNum,$WillNum,$ChooseNum)&quot;; 执行语句12345678910111213141516if($getCon-&gt;query($insCourse)){ echo &quot; &lt;script&gt; alert('插入成功'); self.location='../../teaCon/courseShow.php'; &lt;/script&gt; &quot;;}else{ echo &quot; &lt;script&gt; alert('插入失败'); window.history.go(-1);//返回上一级 &lt;/script&gt; &quot;;} 修改课程条件查询1$selCourseWhe=&quot;select * from course where CouNo = $CouNo&quot;; 获取数据12345678910$CouNo=$_POST['CouNo'];$CouName=$_POST['CouName'];$Kind=$_POST['Kind'];$Credit=$_POST['Credit'];$Teacher=$_POST['Teacher'];$DepartNo=$_POST['DepartNo'];$SchoolTime=$_POST['SchoolTime'];$LimitNum=$_POST['LimitNum'];$WillNum=$_POST['WillNum'];$ChooseNum=$_POST['ChooseNum']; 更新语句123456789101112$updCourse=&quot;UPDATE course SET CouNo=$CouNo, CouName='$CouName', Kind='$Kind', Credit=$Credit, Teacher='$Teacher', DepartNo=$DepartNo, SchoolTime='$SchoolTime', LimitNum=$LimitNum, WillNum=$WillNum, ChooseNum=$ChooseNumWHERE CouNo=$CouNo;&quot;; 执行语句123456789101112if($getCon-&gt;query($updCourse)){ echo &quot;&lt;script&gt; alert('修改成功'); self.location='../../teaCon/courseUpdata.php'; &lt;/script&gt;&quot;;}else{ echo &quot;&lt;script&gt; alert('修改失败'); window.history.go(-1); &lt;/script&gt;&quot;; } 删除课程删除语句1$delCourse=&quot;DELETE FROM course WHERE CouNo=$CouNo;&quot;; 执行语句1234567891011if($getCon-&gt;query($delCourse)){ echo &quot;&lt;script&gt; alert('删除成功'); self.location='../../teaCon/courseUpdata.php'; &lt;/script&gt;&quot;; } else{ echo &quot;&lt;script&gt; alert('删除失败'); &lt;/script&gt;&quot;; } 搜索课程获取条件12$Condition=$_POST['Condition'];$Search=$_POST['Search']; 模糊搜索1$selCourse=&quot;select*from course where $Condition like '%$Search%'&quot;; 执行语句1$resSel=mysqli_query($getCon,$selCourse); 遍历输出12345678910111213141516while($row=mysqli_fetch_array($resSel)){ echo&quot; &lt;tr class=\\&quot;showCouCen\\&quot;&gt; &lt;td&gt;{$row['CouNo']}&lt;/td&gt; &lt;td&gt;{$row['CouName']}&lt;/td&gt; &lt;td&gt;{$row['Kind']}&lt;/td&gt; &lt;td&gt;{$row['Credit']}&lt;/td&gt; &lt;td&gt;{$row['Teacher']}&lt;/td&gt; &lt;td&gt;{$row['DepartNo']}&lt;/td&gt; &lt;td&gt;{$row['SchoolTime']}&lt;/td&gt; &lt;td&gt;{$row['LimitNum']}&lt;/td&gt; &lt;td&gt;{$row['WillNum']}&lt;/td&gt; &lt;td&gt;{$row['ChooseNum']}&lt;/td&gt; &lt;/tr&gt; &quot;; }","link":"/2021/06/23/%E5%AD%A6%E6%A0%A1%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2021-06-26-PHP%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/"},{"title":"Hexo文章简单编写基础","text":"新建一篇文章12hexo new [layout] &lt;title&gt;hexo n [layout] &lt;title&gt; 文章属性编辑123456789101112131415---title: date: urlname: #自定义文章URLcategories: - 分类1 - 分类2tags: - 标签1 - 标签2thumbnail: #文章预览图comments: true #评论系统toc: true #目录mathjax: true #公式渲染--- 文章内容写法标题三级标题四级标题五级标题六级标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 列表&gt; 列表 子列表1 子列表2 子列表3 123- 列表* 列表+ 列表 区块引用123&gt; 注意!!!!&gt;&gt; 这是二级引用!!!!&gt;&gt;&gt; 这是三级!!!! 注意!!! 这是二级引用!!!! 这是三级!!!! 这是分割线123***---___ 链接1&gt; [去百度](https://www.baidu.com) 去百度 1&lt;p&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;还可以这样去百度&lt;/a&gt;&lt;/p&gt; 还可以这样去百度 代码框 单行代码`` &lt;span&gt;好耶&lt;/span&gt; 多行代码 12345```bash 注释&lt;span&gt;好耶&lt;/span&gt;&lt;span&gt;禁止好耶&lt;/span&gt;&lt;span&gt;好耶&lt;/span&gt;``` 强调 字体倾斜字体倾斜字体加粗字体加粗 1234*字体倾斜*_字体倾斜_**字体加粗**__字体加粗__ 删除线 删除 1~~删除~~","link":"/2021/01/16/Hexo%E4%B8%8EmarkDown-2021-01-16-Hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"markDown简单格式","text":"新建一篇文章12hexo new [layout] &lt;title&gt;hexo n [layout] &lt;title&gt; 文章属性编辑123456789101112131415---title: date: urlname: #自定义文章URLcategories: - 分类1 - 分类2tags: - 标签1 - 标签2thumbnail: #文章预览图comments: true #评论系统toc: true #目录mathjax: true #公式渲染--- 文章内容写法标题 三级标题 四级标题 五级标题 12345# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题 列表&gt; 列表 子列表1 子列表2 子列表3 123- 列表* 列表+ 列表 区块引用123&gt; 注意!!!!&gt;&gt; 这是二级引用!!!!&gt;&gt;&gt; 这是三级!!!! 注意!!! 这是二级引用!!!! 这是三级!!!! 这是分割线123***---___ 链接1&gt; [去百度](https://www.baidu.com) 去百度 1&lt;p&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;还可以这样去百度&lt;/a&gt;&lt;/p&gt; 还可以这样去百度 代码框 单行代码`` &lt;span&gt;好耶&lt;/span&gt; 多行代码 12345```bash 注释&lt;span&gt;好耶&lt;/span&gt;&lt;span&gt;禁止好耶&lt;/span&gt;&lt;span&gt;好耶&lt;/span&gt;``` 强调 字体倾斜字体倾斜字体加粗字体加粗 1234*字体倾斜*_字体倾斜_**字体加粗**__字体加粗__ 删除线 删除 1~~删除~~","link":"/2021/01/16/Hexo%E4%B8%8EmarkDown-2021-01-16-markDown%E7%AE%80%E5%8D%95%E6%A0%BC%E5%BC%8F/"},{"title":"Hexo使用与部署","text":"Hexo使用以及部署到仓库 HexoHexo安装 1npm install hexo-cli -g 创建Hexo所需文件 123hexo init myBlogcd myBlognpm install Hexo目录 12345678_config.yml-----网站的配置信息，可在此配置大部分的参数package.jsonscaffolds-------模版文件夹source----------资源文件夹，除 _posts 文件，其他以下划线_开头 的文件或者文件夹不会被编译打包到public文件夹 _drafts-----草稿文件 _posts------文章Markdowm文件 themes----------主题文件夹 Hexo常用命令 123npm install hexo -g------安装npm update hexo -g-------升级hexo init----------------初始化博客 12345hexo n 文章---------新建文章hexo g-------------生成hexo s-------------启动服务hexo d-------------部署hexo clean---------清理缓存 创建SSH Key要使用 git 工具要先配置SSH key，为部署本地博客到 Github 做准备。 在git Bash Here中输入cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用 cat ~/.ssh/id_rsa.pub 命令就可以查看本机上的 SSH key 。 如果之前没创建，则全局配置本地用户 12git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱地址&quot; 生成SSH Key 1ssh-keygen -t rsa -C '邮箱地址' 然后回车，出现 Overwrite (y/n)?,则输入y，若没有则一直回车。 生成的ssh路径在C:\\Users\\Seto\\.sshid_rsa私人密钥id_rsa.pub公共密钥用记事本打开复制id_rsa.pub里面的内容 或直接在git Bash Here获取SSH Key 1cat ~/.ssh/id_rsa.pub 创建仓库基于GitHub创建新建github用户名.github.io仓库 打开GitHub设置添加刚生成的SSH Key 填入刚查到的SSH Key 验证是否设置成功 1ssh -T git@github.com 基于Gitee创建新建仓库 添加公链 验证是否设置成功 1ssh -T git@gitee.com 输入yes并回车 部署到仓库安装部署插件hexo-deployer-git 1npm install hexo-deployer-git --save 部署到GitHub修改配置文件 修改根目录下**-config.yml**文件 给hexo d命令做部署位置的配置，让hexo知道部署在GitHub仓库 执行命令部署上传 1hexo g -d 图床","link":"/2021/09/11/Hexo%E4%B8%8EmarkDown-2021-09-11-Hexo%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%83%A8%E7%BD%B2/"},{"title":"卡通角色建模","text":"做的丑也要做的一个卡通素体的建模过程 头部 身体我也不知道咋整，靠感觉吧 测试一 手部 好吧，我已经不知道怎么做手了，直接用以前做完的。","link":"/2021/09/10/%E5%BB%BA%E6%A8%A1-2021-09-10-%E5%8D%A1%E9%80%9A%E8%A7%92%E8%89%B2%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"角色建模","slug":"角色建模","link":"/tags/%E8%A7%92%E8%89%B2%E5%BB%BA%E6%A8%A1/"},{"name":"建模流程","slug":"建模流程","link":"/tags/%E5%BB%BA%E6%A8%A1%E6%B5%81%E7%A8%8B/"},{"name":"卡通","slug":"卡通","link":"/tags/%E5%8D%A1%E9%80%9A/"},{"name":"期末作业","slug":"期末作业","link":"/tags/%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Shader","slug":"Shader","link":"/tags/Shader/"},{"name":"简单","slug":"简单","link":"/tags/%E7%AE%80%E5%8D%95/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"},{"name":"markDown","slug":"markDown","link":"/tags/markDown/"},{"name":"TA","slug":"TA","link":"/tags/TA/"}],"categories":[{"name":"建模","slug":"建模","link":"/categories/%E5%BB%BA%E6%A8%A1/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"TA","slug":"TA","link":"/categories/TA/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"markDown","slug":"markDown","link":"/categories/markDown/"},{"name":"Unity","slug":"Unity","link":"/categories/Unity/"}]}